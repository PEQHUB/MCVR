#version 460
#extension GL_GOOGLE_include_directive : require

#include "common/shared.hpp"

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// Binding 0 is typically the output storage image
layout(set = 0, binding = 0, rgba16f) uniform image2D outputImage;

// Denoised results from previous passes (as Samplers for better stability)
layout(set = 0, binding = 1) uniform sampler2D directLightingSampler;      
layout(set = 0, binding = 2) uniform sampler2D denoisedDiffuseSampler;     
layout(set = 0, binding = 3) uniform sampler2D denoisedSpecularSampler;    
layout(set = 0, binding = 4) uniform sampler2D diffuseAlbedoSampler;       
layout(set = 0, binding = 5) uniform sampler2D normalRoughnessSampler;     
layout(set = 0, binding = 6) uniform sampler2D linearDepthSampler;

layout(set = 0, binding = 7) uniform WorldUniform {
    WorldUBO worldUBO;
};

layout(set = 0, binding = 8) uniform sampler2D specularAlbedoSampler;      
layout(set = 0, binding = 9) uniform sampler2D clearRadianceSampler;       
layout(set = 0, binding = 10) uniform sampler2D baseEmissionSampler;       

float luminance(vec3 c) {
    return dot(c, vec3(0.2126, 0.7152, 0.0722));
}

vec3 YCoCgToRGB(vec3 ycocg) {
    float Y = ycocg.x;
    float Co = ycocg.y;
    float Cg = ycocg.z;
    float t = Y - Cg;
    float G = Y + Cg;
    float R = t + Co;
    float B = t - Co;
    return vec3(R, G, B);
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(outputImage);
    if (pixel.x >= size.x || pixel.y >= size.y) return;

    // 1. Fetch Denoised Signals (Radiance domain)
    vec3 directRadiance = texelFetch(directLightingSampler, pixel, 0).rgb;
    vec3 denoisedDiffuse = texelFetch(denoisedDiffuseSampler, pixel, 0).rgb;
    vec3 denoisedSpecular = YCoCgToRGB(texelFetch(denoisedSpecularSampler, pixel, 0).rgb);
    
    vec4 albedoPacked = texelFetch(diffuseAlbedoSampler, pixel, 0);
    vec3 albedo = albedoPacked.rgb;
    float metallic = albedoPacked.a;
    
    float depth = texelFetch(linearDepthSampler, pixel, 0).r;
    vec3 clearRadiance = texelFetch(clearRadianceSampler, pixel, 0).rgb;
    vec3 baseEmission = texelFetch(baseEmissionSampler, pixel, 0).rgb;

    // 2. Simple Additive Merge
    // Remove Fresnel to improve edge stability and match NRD path.
    vec3 outColor;
    bool isTranslucent = (luminance(albedo) < 0.02 && metallic < 0.1);

    vec3 indirectDiffuse = denoisedDiffuse * albedo;
    
    if (isTranslucent) {
        outColor = denoisedSpecular + directRadiance + baseEmission + clearRadiance;
    } else {
        outColor = indirectDiffuse + directRadiance + denoisedSpecular + baseEmission + clearRadiance;
    }

    // Handle Sky
    if (depth >= INF_DISTANCE - 1.0 && dot(outColor, outColor) < 1e-6) {
        outColor = denoisedDiffuse;
    }

    if (any(isnan(outColor))) outColor = vec3(0.0);
    imageStore(outputImage, pixel, vec4(max(outColor, vec3(0.0)), 1.0));
}