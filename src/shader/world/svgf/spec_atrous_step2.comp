#version 460
#extension GL_GOOGLE_include_directive : require

#include "common/shared.hpp"

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba16f) uniform image2D specInputImage;
layout(set = 0, binding = 1, rgba16f) uniform image2D specOutputImage;
layout(set = 0, binding = 2, r32f) uniform image2D linearDepthImage;
layout(set = 0, binding = 3, rgba16f) uniform image2D normalRoughnessImage;
layout(set = 0, binding = 4, r16f) uniform image2D specVarianceInput;
layout(set = 0, binding = 5, rgba16f) uniform image2D specularAlbedoImage;
layout(set = 0, binding = 6, r16f) uniform image2D specVarianceOutput;

const int STEP_SIZE = 2;

layout(push_constant) uniform PushConstants {
    float phiColor;
} pushConstants;
#define kPhiColor pushConstants.phiColor

const float kPhiNormal = 64.0;

float computeVarianceCenter(ivec2 pixel, ivec2 size) {
    const float kernel[2][2] = float[2][2](float[2](0.25, 0.125), float[2](0.125, 0.0625));
    float sum = 0.0;
    for (int dy = -1; dy <= 1; ++dy) {
        for (int dx = -1; dx <= 1; ++dx) {
            ivec2 q = pixel + ivec2(dx, dy);
            if (q.x < 0 || q.y < 0 || q.x >= size.x || q.y >= size.y) continue;
            float k = kernel[abs(dx)][abs(dy)];
            sum += imageLoad(specVarianceInput, q).r * k;
        }
    }
    return sum;
}

float estimateDepthFwidth(float centerDepth, ivec2 pixel, ivec2 size) {
    float dx = (pixel.x + 1 < size.x) ? abs(centerDepth - imageLoad(linearDepthImage, pixel + ivec2(1, 0)).r) : 0.0;
    float dy = (pixel.y + 1 < size.y) ? abs(centerDepth - imageLoad(linearDepthImage, pixel + ivec2(0, 1)).r) : 0.0;
    return max(max(dx, dy), 1e-4);
}

float luminance(vec3 c) {

    return c.x; // Y channel in YCoCg

}
vec3 normalizeSafe(vec3 v) { float len = length(v); return (len > 1e-4) ? (v / len) : vec3(0.0, 0.0, 1.0); }

float computeWeight(float depthCenter, float depthP, float phiDepth, vec3 normalCenter, vec3 normalP,
                    float lumCenter, float lumP, float phiColor, float roughness) {
    float normalPower = mix(kPhiNormal, 32.0, roughness);
    float wNormal = pow(max(0.0, dot(normalCenter, normalP)), normalPower);
    float wZ = abs(depthCenter - depthP) / max(phiDepth, 1e-4);
    float wL = abs(lumCenter - lumP) / max(phiColor, 1e-4);
    return exp(-max(wL, 0.0) - max(wZ, 0.0)) * wNormal;
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(specInputImage);
    if (pixel.x >= size.x || pixel.y >= size.y) return;

    vec3 centerColor = imageLoad(specInputImage, pixel).rgb;
    float centerDepth = imageLoad(linearDepthImage, pixel).r;
    vec4 normalRoughness = imageLoad(normalRoughnessImage, pixel);
    vec3 centerNormal = normalRoughness.xyz;
    float roughness = normalRoughness.w * normalRoughness.w;
    float varianceCenter = imageLoad(specVarianceInput, pixel).r;
    float varianceForPhi = computeVarianceCenter(pixel, size);

    if (centerDepth >= (INF_DISTANCE * 0.5)) {
        imageStore(specOutputImage, pixel, vec4(centerColor, 1.0));
        imageStore(specVarianceOutput, pixel, vec4(varianceCenter, 0.0, 0.0, 0.0));
        return;
    }

    float centerLum = luminance(centerColor);
    vec3 nCenter = normalizeSafe(centerNormal);
    float fwidthZ = estimateDepthFwidth(centerDepth, pixel, size);
    float depthScale = mix(5.0, 10.0, roughness);
    float relativeDepthThreshold = max(centerDepth * 0.01, 0.1);
    float phiDepth = max(fwidthZ * float(STEP_SIZE) * depthScale, relativeDepthThreshold);

    // --- ENHANCED FOR STEP 2: Dark-Aware & Variance-Guided phiL ---
    float darkAreaBoost = mix(3.5, 1.0, smoothstep(0.0, 0.2, centerLum)); // Stronger than Step 1
    
    // Smooth surfaces need more blurring to hide 1spp noise
    float basePhiL = kPhiColor;
    if (roughness < 0.1) basePhiL *= 2.5; // More aggressive for smooth surfaces in Step 2
    
    // Variance-Guided: If variance is high, increase phiL to blur more
    float varianceScale = 1.0 + sqrt(max(varianceForPhi, 0.0)) * 2.0;
    float phiL = max(basePhiL, 16.0) * darkAreaBoost * varianceScale;

    float sumW = 1.0;
    vec3 sumC = centerColor;
    float sumVarW2 = varianceCenter;

    const float kernel[5] = float[5](1.0, 2.0, 3.0, 2.0, 1.0);
    const float kernelNorm = 9.0;

    for (int dy = -2; dy <= 2; ++dy) {
        for (int dx = -2; dx <= 2; ++dx) {
            if (dx == 0 && dy == 0) continue;
            ivec2 q = pixel + ivec2(dx * STEP_SIZE, dy * STEP_SIZE);
            if (q.x < 0 || q.y < 0 || q.x >= size.x || q.y >= size.y) continue;
            vec3 c = imageLoad(specInputImage, q).rgb;
            float d = imageLoad(linearDepthImage, q).r;
            vec3 n = normalizeSafe(imageLoad(normalRoughnessImage, q).xyz);
            float lum = luminance(c);

            float varNeighbor = imageLoad(specVarianceInput, q).r;
            float w = computeWeight(centerDepth, d, phiDepth * length(vec2(dx, dy)), nCenter, n, centerLum, lum, phiL, roughness);

            float wK = w * (kernel[abs(dx)] * kernel[abs(dy)] / (kernelNorm * kernelNorm));
            sumC += c * wK;
            sumW += wK;
            sumVarW2 += varNeighbor * (wK * wK);
        }
    }

    imageStore(specOutputImage, pixel, vec4(sumC / max(sumW, 1e-4), 1.0));
    imageStore(specVarianceOutput, pixel, vec4(sumVarW2 / max(sumW * sumW, 1e-4), 0.0, 0.0, 0.0));
}
