#version 460
#extension GL_GOOGLE_include_directive : require

#include "common/shared.hpp"

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// Using Samplers + texelFetch for optimized data access
layout(set = 0, binding = 0) uniform sampler2D giHistorySampler;
layout(set = 0, binding = 1, rg16f) uniform image2D giMomentsImage;
layout(set = 0, binding = 2, r16f) uniform image2D giVarianceImage;
layout(set = 0, binding = 3) uniform sampler2D giMomentsPrevSampler;
layout(set = 0, binding = 4) uniform sampler2D giHistoryLengthSampler;

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(giMomentsImage);
    if (pixel.x >= size.x || pixel.y >= size.y) return;

    // --- 1. Compute Spatial Moments (3x3) using texelFetch ---
    float sumL = 0.0;
    float sumL2 = 0.0;
    float count = 0.0;
    
    for (int dy = -1; dy <= 1; ++dy) {
        for (int dx = -1; dx <= 1; ++dx) {
            ivec2 q = pixel + ivec2(dx, dy);
            if (q.x < 0 || q.y < 0 || q.x >= size.x || q.y >= size.y) continue;
            
            vec3 gi = texelFetch(giHistorySampler, q, 0).rgb;
            float L = dot(gi, vec3(0.2126, 0.7152, 0.0722));
            sumL += L;
            sumL2 += L * L;
            count += 1.0;
        }
    }
    float invCount = 1.0 / max(count, 1.0);
    float m1 = sumL * invCount;
    float m2 = sumL2 * invCount;

    // --- 2. Temporal Accumulation ---
    float historyLength = texelFetch(giHistoryLengthSampler, pixel, 0).r;
    if (historyLength > 1.1) {
        vec2 prev = texelFetch(giMomentsPrevSampler, pixel, 0).rg;
        float alpha = clamp(1.0 / historyLength, 0.02, 0.2);
        m1 = mix(prev.x, m1, alpha);
        m2 = mix(prev.y, m2, alpha);
    }
    
    float variance = max(m2 - m1 * m1, 0.0);

    imageStore(giMomentsImage, pixel, vec4(m1, m2, 0.0, 0.0));
    imageStore(giVarianceImage, pixel, vec4(variance, 0.0, 0.0, 0.0));
}