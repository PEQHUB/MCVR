#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

#include "../util/labpbr.glsl"
#include "../util/random.glsl"
#include "../util/ray_payloads.glsl"
#include "../util/util.glsl"
#include "common/shared.hpp"

layout(set = 0, binding = 0) uniform sampler2D textures[];

layout(set = 1, binding = 0) uniform accelerationStructureEXT topLevelAS;

layout(set = 1, binding = 1) readonly buffer BLASOffsets {
    uint offsets[];
}
blasOffsets;

layout(set = 1, binding = 2) readonly buffer VertexBufferAddr {
    uint64_t addrs[];
}
vertexBufferAddrs;

layout(set = 1, binding = 3) readonly buffer IndexBufferAddr {
    uint64_t addrs[];
}
indexBufferAddrs;

layout(set = 1, binding = 7) readonly buffer TextureMappingBuffer {
    TextureMapping mapping;
};

layout(set = 2, binding = 0) uniform Uniform {
    WorldUBO ubo;
};

layout(std430, buffer_reference, buffer_reference_align = 8) readonly buffer VertexBuffer {
    PBRTriangle vertices[];
}
vertexBuffer;

layout(std430, buffer_reference, buffer_reference_align = 8) readonly buffer IndexBuffer {
    uint indices[];
}
indexBuffer;

layout(location = 1) rayPayloadInEXT ShadowRay shadowRay;
hitAttributeEXT vec2 attribs;

void main() {
    uint instanceID = gl_InstanceCustomIndexEXT;
    uint geometryID = gl_GeometryIndexEXT;

    uint blasOffset = blasOffsets.offsets[instanceID];

    IndexBuffer indexBuffer = IndexBuffer(indexBufferAddrs.addrs[blasOffset + geometryID]);
    uint indexBaseID = 3 * gl_PrimitiveID;
    uint i0 = indexBuffer.indices[indexBaseID];
    uint i1 = indexBuffer.indices[indexBaseID + 1];
    uint i2 = indexBuffer.indices[indexBaseID + 2];

    VertexBuffer vertexBuffer = VertexBuffer(vertexBufferAddrs.addrs[blasOffset + geometryID]);
    PBRTriangle v0 = vertexBuffer.vertices[i0];
    PBRTriangle v1 = vertexBuffer.vertices[i1];
    PBRTriangle v2 = vertexBuffer.vertices[i2];

    vec3 baryCoords = vec3(1.0 - (attribs.x + attribs.y), attribs.x, attribs.y);
    vec2 uv = baryCoords.x * v0.textureUV + baryCoords.y * v1.textureUV + baryCoords.z * v2.textureUV;
    uint textureID = v0.textureID;
    uint useColorLayer = v0.useColorLayer;
    vec4 colorLayer;
    if (useColorLayer > 0) {
        colorLayer = (baryCoords.x * v0.colorLayer + baryCoords.y * v1.colorLayer + baryCoords.z * v2.colorLayer);
    } else {
        colorLayer = vec4(1.0);
    }

    uint useTexture = v0.useTexture;
    vec2 textureUV;
    vec4 albedo;
    ivec4 flags;
    vec4 specular = vec4(0.0);
    vec4 normalVal = vec4(0.0);

    if (useTexture > 0) {
        textureUV = baryCoords.x * v0.textureUV + baryCoords.y * v1.textureUV + baryCoords.z * v2.textureUV;
        albedo = texture(textures[nonuniformEXT(textureID)], textureUV);

        int specularTextureID = mapping.entries[textureID].specular;
        if (specularTextureID >= 0) { specular = texture(textures[nonuniformEXT(specularTextureID)], textureUV); }

        int flagTextureID = mapping.entries[textureID].flag;
        if (flagTextureID >= 0) {
            vec4 floatFlagValue = textureLod(textures[nonuniformEXT(flagTextureID)], uv, 0);
            flags = ivec4(round(floatFlagValue * 255.0));
        } else {
            flags = ivec4(0);
        }
    } else {
        albedo = vec4(1.0);
        flags = ivec4(0);
    }

    // if insideBoat, then ignore liquid
    if (shadowRay.insideBoat > 0 && (flags.r & 0x1) > 0) {
        ignoreIntersectionEXT;
        return;
    }

    uint useGlint = v0.useGlint;
    uint glintTexture = v0.glintTexture;
    vec2 glintUV = baryCoords.x * v0.glintUV + baryCoords.y * v1.glintUV + baryCoords.z * v2.glintUV;
    glintUV = (ubo.textureMat * vec4(glintUV, 0.0, 1.0)).xy;
    vec3 glint = useGlint * texture(textures[nonuniformEXT(glintTexture)], glintUV).rgb;
    glint = glint * glint;

    uint useOverlay = v0.useOverlay;
    ivec2 overlayUV = v0.overlayUV;
    vec4 overlayColor = texelFetch(textures[nonuniformEXT(ubo.overlayTextureID)], overlayUV, 0);

    vec3 tint = (albedo * colorLayer).rgb;
    float alpha = (albedo * colorLayer).a;
    if (useOverlay > 0) {
        tint = mix(overlayColor.rgb, tint, overlayColor.a) + glint;
    } else {
        tint += glint;
    }

    LabPBRMat mat = convertLabPBRMaterial(albedo * colorLayer, specular, normalVal);

    if (alpha < 0.05) {
        // cut-out
        ignoreIntersectionEXT;
    } else if (mat.transmission > 0.0) {
        shadowRay.throughput *= tint;
        ignoreIntersectionEXT;
    } else if (alpha < 0.95) {
        // translucent
        if (rand(shadowRay.seed) < alpha) {
            // accept the ray
            shadowRay.throughput *= tint;
            ignoreIntersectionEXT;
        } else {
            // pass through
            ignoreIntersectionEXT;
        }
    } else {
        // opaque
        terminateRayEXT;
    }
}