#version 460
#define NUM_BINS 256

layout(set = 0, binding = 1) buffer HistogramBuffer {
    uint bins[NUM_BINS];
}
gHist;

layout(set = 0, binding = 2) buffer ExposureBuffer {
    float exposure;
    float avgLogLum;
    float tonemapMode;
    float Lwhite;
    float exposureCompensation;
    // HDR fields (appended)
    float hdrPipelineEnabled;
    float hdr10OutputEnabled;
    float peakNits;
    float paperWhiteNits;
    float saturation;
    float sdrTransferFunction;
    float capExposureSmoothed;
}
expData;

layout(push_constant) uniform PushConstant {
    float log2Min;
    float log2Max;
    float epsilon;
    float lowPercent;
    float highPercent;
    float middleGrey;
    float dt;
    float speedUp;
    float speedDown;
    float brightAdaptBoost;
    float minExposure;
    float maxExposure;
    float tonemapMode;
    float Lwhite;
    float exposureCompensation;
    float legacyExposure;
    float highlightPercent;
    float highlightProtection;
    float highlightSmoothingSpeed;
    // HDR fields
    float hdrPipelineEnabled;
    float hdr10OutputEnabled;
    float peakNits;
    float paperWhiteNits;
    float saturation;
    float sdrTransferFunction;
}
pc;

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

void main() {
    uint total = 0u;
    for (uint i = 0u; i < NUM_BINS; ++i) total += gHist.bins[i];

    if (total == 0u) {
        expData.avgLogLum = pc.log2Min;
        expData.exposure = clamp(expData.exposure, pc.minExposure, pc.maxExposure);
        return;
    }

    float fTotal = float(total);
    uint lowCount = uint(clamp(pc.lowPercent, 0.0, 1.0) * fTotal);
    uint highCount = uint(clamp(pc.highPercent, 0.0, 1.0) * fTotal);
    if (highCount <= lowCount) highCount = lowCount + 1u;

    uint cumulative = 0u;
    double sumLog = 0.0;
    uint used = 0u;

    float binCountF = float(NUM_BINS);
    float log2Range = pc.log2Max - pc.log2Min;

    for (uint i = 0u; i < NUM_BINS; ++i) {
        uint c = gHist.bins[i];
        if (c == 0u) continue;

        uint next = cumulative + c;

        uint a = max(cumulative, lowCount);
        uint b = min(next, highCount);
        if (b > a) {
            uint take = b - a;

            float t = (float(i) + 0.5) / binCountF;
            float logLum = pc.log2Min + t * log2Range;

            sumLog += double(logLum) * double(take);
            used += take;
        }
        cumulative = next;
        if (cumulative >= highCount) break;
    }

    float avgLogLum = (used > 0u) ? float(sumLog / double(used)) : pc.log2Min;
    float avgLum = exp2(avgLogLum);

    // Legacy target: expose middle-grey to the trimmed mean.
    float targetExposure = pc.middleGrey / max(avgLum, 1e-6);
    // Work in compensated exposure space for temporal adaptation.
    float targetComp = targetExposure * exp2(pc.exposureCompensation);

    float highlightMix = 0.0;
    float capExposureRaw = 3.4e38; // effectively no cap
    float capExposure = 3.4e38;

    // Optional highlight protection for improved mode. Legacy mode keeps legacy failure modes.
    if (pc.legacyExposure < 0.5 && pc.highlightProtection > 0.0) {
        highlightMix = clamp(pc.highlightProtection, 0.0, 1.0);
        // Find log luminance at a high percentile of the histogram CDF.
        uint hiCount = uint(clamp(pc.highlightPercent, 0.0, 1.0) * fTotal);
        hiCount = clamp(hiCount, 1u, total);

        uint cum2 = 0u;
        uint hiBin = NUM_BINS - 1u;
        uint cumBeforeHi = 0u;
        for (uint i = 0u; i < NUM_BINS; ++i) {
            cum2 += gHist.bins[i];
            if (cum2 >= hiCount) {
                hiBin = i;
                cumBeforeHi = cum2 - gHist.bins[i];
                break;
            }
        }

        // If the highlight tail is extremely small (e.g. sun disc), reduce highlight influence.
        // Prevents the entire scene from going near-black just to preserve a few pixels.
        float tailCount = float(total - cumBeforeHi);
        float tailFrac = tailCount / fTotal;
        float tailWeight = smoothstep(0.002, 0.02, tailFrac); // 0.2%..2% of pixels
        highlightMix *= tailWeight;

        float tHi = (float(hiBin) + 0.5) / binCountF;
        float hiLogLum = pc.log2Min + tHi * log2Range;
        float hiLum = exp2(hiLogLum);

        float paperWhite = max(pc.paperWhiteNits, 1e-6);
        float headroom = max(pc.peakNits / paperWhite, 1.0);
        float highlightTarget = (pc.hdr10OutputEnabled > 0.5) ? headroom : 1.0;
        capExposureRaw = highlightTarget / max(hiLum, 1e-6);

        // Temporal smoothing for the highlight cap to reduce percentile noise.
        // Uses log-domain smoothing so it behaves well across many stops.
        float smoothSpeed = max(pc.highlightSmoothingSpeed, 0.0);
        if (smoothSpeed > 0.0) {
            float prevCap = expData.capExposureSmoothed;
            if (prevCap <= 0.0) prevCap = capExposureRaw;

            float prevLog = log2(max(prevCap, 1e-6));
            float rawLog = log2(max(capExposureRaw, 1e-6));

            // Keep symmetric smoothing: tightening too fast looks unnatural.
            float dirSpeed = smoothSpeed;
            float kCap = 1.0 - exp(-pc.dt * dirSpeed);
            float smLog = mix(prevLog, rawLog, clamp(kCap, 0.0, 1.0));
            capExposure = exp2(smLog);
        } else {
            capExposure = capExposureRaw;
        }

        expData.capExposureSmoothed = capExposure;

        float capped = min(targetComp, capExposure);
        targetComp = mix(targetComp, capped, highlightMix);
    }

    float prevComp = expData.exposure;
    if (prevComp <= 0.0) prevComp = targetComp;

    // Natural adaptation: clamp EV change per second.
    float prevEV = log2(max(prevComp, 1e-6));
    float targetEV = log2(max(targetComp, 1e-6));

    float upRate = max(pc.speedUp, 0.0);
    float downRate = max(pc.speedDown, 0.0);
    if (pc.legacyExposure < 0.5 && targetEV < prevEV) {
        downRate *= max(pc.brightAdaptBoost, 1.0);
    }

    float maxUp = upRate * pc.dt;
    float maxDown = downRate * pc.dt;
    float delta = clamp(targetEV - prevEV, -maxDown, +maxUp);
    float adaptedComp = exp2(prevEV + delta);

    expData.avgLogLum = avgLogLum;
    expData.exposure = clamp(adaptedComp, pc.minExposure, pc.maxExposure);
    expData.tonemapMode = pc.tonemapMode;
    expData.Lwhite = pc.Lwhite;
    expData.exposureCompensation = pc.exposureCompensation;
    // Pass through HDR settings to fragment shader
    expData.hdrPipelineEnabled = pc.hdrPipelineEnabled;
    expData.hdr10OutputEnabled = pc.hdr10OutputEnabled;
    expData.peakNits = pc.peakNits;
    expData.paperWhiteNits = pc.paperWhiteNits;
    expData.saturation = pc.saturation;
    expData.sdrTransferFunction = pc.sdrTransferFunction;
}
