#version 460
#define NUM_BINS 256

layout(set = 0, binding = 1) buffer HistogramBuffer {
    uint bins[NUM_BINS];
}
gHist;

layout(set = 0, binding = 2) buffer ExposureBuffer {
    float exposure;
    float avgLogLum;
    float tonemapMode;
    float Lwhite;
    float exposureCompensation;
    // HDR fields (appended)
    float hdrPipelineEnabled;
    float hdr10OutputEnabled;
    float peakNits;
    float paperWhiteNits;
    float saturation;
    float sdrTransferFunction;
}
expData;

layout(push_constant) uniform PushConstant {
    float log2Min;
    float log2Max;
    float epsilon;
    float lowPercent;
    float highPercent;
    float middleGrey;
    float dt;
    float speedUp;
    float speedDown;
    float minExposure;
    float maxExposure;
    float tonemapMode;
    float Lwhite;
    float exposureCompensation;
    float legacyExposure;
    float highlightPercent;
    float highlightProtection;
    // HDR fields
    float hdrPipelineEnabled;
    float hdr10OutputEnabled;
    float peakNits;
    float paperWhiteNits;
    float saturation;
    float sdrTransferFunction;
}
pc;

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

void main() {
    uint total = 0u;
    for (uint i = 0u; i < NUM_BINS; ++i) total += gHist.bins[i];

    if (total == 0u) {
        expData.avgLogLum = pc.log2Min;
        expData.exposure = clamp(expData.exposure, pc.minExposure, pc.maxExposure);
        return;
    }

    float fTotal = float(total);
    uint lowCount = uint(clamp(pc.lowPercent, 0.0, 1.0) * fTotal);
    uint highCount = uint(clamp(pc.highPercent, 0.0, 1.0) * fTotal);
    if (highCount <= lowCount) highCount = lowCount + 1u;

    uint cumulative = 0u;
    double sumLog = 0.0;
    uint used = 0u;

    float binCountF = float(NUM_BINS);
    float log2Range = pc.log2Max - pc.log2Min;

    for (uint i = 0u; i < NUM_BINS; ++i) {
        uint c = gHist.bins[i];
        if (c == 0u) continue;

        uint next = cumulative + c;

        uint a = max(cumulative, lowCount);
        uint b = min(next, highCount);
        if (b > a) {
            uint take = b - a;

            float t = (float(i) + 0.5) / binCountF;
            float logLum = pc.log2Min + t * log2Range;

            sumLog += double(logLum) * double(take);
            used += take;
        }
        cumulative = next;
        if (cumulative >= highCount) break;
    }

    float avgLogLum = (used > 0u) ? float(sumLog / double(used)) : pc.log2Min;
    float avgLum = exp2(avgLogLum);

    // Legacy target: expose middle-grey to the trimmed mean.
    float targetExposure = pc.middleGrey / max(avgLum, 1e-6);

    float highlightMix = 0.0;
    float capExposure = 3.4e38; // effectively no cap

    // Optional highlight protection for improved mode. Legacy mode keeps legacy failure modes.
    if (pc.legacyExposure < 0.5 && pc.highlightProtection > 0.0) {
        highlightMix = clamp(pc.highlightProtection, 0.0, 1.0);
        // Find log luminance at a high percentile of the histogram CDF.
        uint hiCount = uint(clamp(pc.highlightPercent, 0.0, 1.0) * fTotal);
        hiCount = clamp(hiCount, 1u, total);

        uint cum2 = 0u;
        uint hiBin = NUM_BINS - 1u;
        for (uint i = 0u; i < NUM_BINS; ++i) {
            cum2 += gHist.bins[i];
            if (cum2 >= hiCount) { hiBin = i; break; }
        }

        float tHi = (float(hiBin) + 0.5) / binCountF;
        float hiLogLum = pc.log2Min + tHi * log2Range;
        float hiLum = exp2(hiLogLum);

        float paperWhite = max(pc.paperWhiteNits, 1e-6);
        float headroom = max(pc.peakNits / paperWhite, 1.0);
        float highlightTarget = (pc.hdr10OutputEnabled > 0.5) ? headroom : 1.0;
        capExposure = highlightTarget / max(hiLum, 1e-6);

        // Apply EV compensation before highlight cap so "looks" can't override safety.
        float targetComp = targetExposure * exp2(pc.exposureCompensation);
        float capped = min(targetComp, capExposure);
        float protectedTarget = mix(targetComp, capped, highlightMix);

        // Convert back to uncompensated target for the temporal filter.
        targetExposure = protectedTarget / exp2(pc.exposureCompensation);
    }

    float prev = expData.exposure;
    float speed = (targetExposure > prev) ? pc.speedUp : pc.speedDown;
    // In improved mode, stop-down (bright adaptation) should be faster.
    if (pc.legacyExposure < 0.5 && targetExposure < prev) {
        speed *= 4.0;
    }
    float k = 1.0 - exp(-pc.dt * speed);
    float adapted = mix(prev, targetExposure, clamp(k, 0.0, 1.0));

    expData.avgLogLum = avgLogLum;
    // Apply EV compensation: multiply by 2^EV
    float compensated = adapted * exp2(pc.exposureCompensation);
    if (highlightMix > 0.0) {
        compensated = mix(compensated, min(compensated, capExposure), highlightMix);
    }
    expData.exposure = clamp(compensated, pc.minExposure, pc.maxExposure);
    expData.tonemapMode = pc.tonemapMode;
    expData.Lwhite = pc.Lwhite;
    expData.exposureCompensation = pc.exposureCompensation;
    // Pass through HDR settings to fragment shader
    expData.hdrPipelineEnabled = pc.hdrPipelineEnabled;
    expData.hdr10OutputEnabled = pc.hdr10OutputEnabled;
    expData.peakNits = pc.peakNits;
    expData.paperWhiteNits = pc.paperWhiteNits;
    expData.saturation = pc.saturation;
    expData.sdrTransferFunction = pc.sdrTransferFunction;
}
